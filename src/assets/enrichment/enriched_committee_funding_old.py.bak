"""
Enriched Committee Funding Sources Asset (Per-Cycle)
Traces money UPSTREAM - who funds committees that donate to tracked candidates.

CANDIDATE-CENTRIC APPROACH:
1. Get tracked candidates' committee IDs from member_fec_mapping
2. Find all committees that donated TO tracked candidate committees (pas2.OTHER_ID)
3. Separate donors by type:
   - Q/N types (Corporate PACs) ‚Üí Reclassify as organizations (no upstream tracing)
   - O/W/I types (Political PACs) ‚Üí Trace upstream funding sources
4. Only create records for committees relevant to tracked candidates

CRITICAL: pas2 contains transactions from FILER's perspective (money OUT), not money IN!
To trace upstream, we query WHERE recipient (OTHER_ID) = target committee.

Currently extracts:
  - Political Committee transfers (Super PACs, ideological PACs, party committees)
  - Corporate/Union PAC contributions (reclassified as from_organizations)
    ‚Ä¢ Q/N type committees = Corporate/Union PACs (no upstream tracing needed)
    ‚Ä¢ W/O/I type committees = Political PACs (trace upstream sources)
  
NOT YET AVAILABLE (need different data sources):
  - Direct individual donations (need indiv.zip parsing - Phase 2)
  - Direct corporate contributions (illegal - corps use PACs instead)

See docs/PAS2_DATA_MODEL.md for detailed explanation of the data model.
"""

from dagster import asset, AssetIn, Config, AssetExecutionContext, Output, MetadataValue
from typing import Dict, Any, Set
from datetime import datetime
from collections import defaultdict

from src.resources.mongo import MongoDBResource


class EnrichedCommitteeFundingConfig(Config):
    """Configuration for enriched_committee_funding asset"""
    cycles: list[str] = ["2020", "2022", "2024", "2026"]
    large_donor_threshold: int = 10000  # Flag individual donations above this amount


@asset(
    name="enriched_committee_funding",
    group_name="enrichment",
    ins={
        "itpas2": AssetIn(key="itpas2"),
        "cm": AssetIn(key="cm"),  # Committee master for types
        "member_fec_mapping": AssetIn(key="member_fec_mapping"),  # NEW: Get tracked committees
    },
    compute_kind="aggregation",
    description="Per-cycle upstream funding sources for committees that donate to tracked candidates"
)
def enriched_committee_funding_asset(
    context: AssetExecutionContext,
    config: EnrichedCommitteeFundingConfig,
    mongo: MongoDBResource,
    itpas2: Dict[str, Any],
    cm: Dict[str, Any],
    member_fec_mapping: Dict[str, Any],  # NEW: Get tracked candidates' committees
) -> Output[Dict[str, Any]]:
    """
    Trace money UPSTREAM for committees that donate to tracked candidates.
    Stored in enriched_{cycle}.committee_funding_sources
    
    CANDIDATE-CENTRIC FLOW:
    1. Get tracked candidates' committee IDs
    2. Find donors TO those committees (pas2 where OTHER_ID = tracked committee)
    3. Separate by type: Q/N (corporate PACs) vs O/W/I (political PACs)
    4. Only trace upstream for political PACs (corporate PACs are ultimate sources)
    
    Structure per committee:
    {
        _id: "C00694323",  // WINRED
        committee_name: "WINRED",
        committee_type: "I",  // Conduit committee
        cycle: "2024",
        donated_to_tracked_candidates: ["S0GA00526", "S8TX00106"],  // Links back to candidates
        
        funding_sources: {
            from_committees: [...],      // Upstream political PACs
            from_individuals: [...],     // Future: from indiv.zip
            from_organizations: [...]    // Reclassified corporate PACs
        },
        
        transparency: {
            total_disclosed: 45000000,
            from_committees: 5000000,
            from_individuals: 40000000,  // Future
            from_organizations: 0,
            transparency_score: 1.0,
            red_flags: []
        },
        
        computed_at: ISODate(...)
    }
    """
    
    stats = {
        'cycles_processed': [],
        'committees_with_funding': 0,
        'tracked_candidate_committees': 0,
        'donor_committees_found': 0,
        'political_pacs_traced': 0,
        'corporate_pacs_reclassified': 0,
        'total_upstream_amount': 0,
    }
    
    with mongo.get_client() as client:
        # ============================================================================
        # STEP 1: Get tracked candidates' committee IDs from member_fec_mapping
        # ============================================================================
        context.log.info("=" * 80)
        context.log.info("STEP 1: Loading tracked candidates' committees")
        context.log.info("=" * 80)
        
        mapping_collection = mongo.get_collection(client, "member_fec_mapping", database_name="aggregation")
        
        tracked_committee_ids = set()
        tracked_candidate_to_committees = {}  # Map candidate_id -> [committee_ids]
        
        for member in mapping_collection.find():
            bioguide_id = member.get('bioguide_id')
            committee_ids = member.get('fec', {}).get('committee_ids', [])
            candidate_ids = member.get('fec', {}).get('candidate_ids', [])
            
            if committee_ids:
                tracked_committee_ids.update(committee_ids)
                
                # Map candidate IDs to their committees
                for cand_id in candidate_ids:
                    if cand_id not in tracked_candidate_to_committees:
                        tracked_candidate_to_committees[cand_id] = []
                    tracked_candidate_to_committees[cand_id].extend(committee_ids)
        
        tracked_committee_ids = list(tracked_committee_ids)
        stats['tracked_candidate_committees'] = len(tracked_committee_ids)
        
        context.log.info(f"‚úÖ Found {len(tracked_committee_ids):,} committee IDs for tracked candidates")
        context.log.info(f"   Mapping covers {len(tracked_candidate_to_committees):,} candidate IDs")
        context.log.info("")
        
        if not tracked_committee_ids:
            context.log.warning("‚ö†Ô∏è  No tracked committees found - skipping upstream tracing")
            return Output(value=stats, metadata={"warning": "No tracked committees found"})
        
        # ============================================================================
        # STEP 2: Process each cycle
        # ============================================================================
        for cycle in config.cycles:
            context.log.info("=" * 80)
            context.log.info(f"STEP 2: Processing cycle {cycle}")
            context.log.info("=" * 80)
            
            itpas2_collection = mongo.get_collection(client, "itpas2", database_name=f"fec_{cycle}")
            cm_collection = mongo.get_collection(client, "cm", database_name=f"fec_{cycle}")
            funding_collection = mongo.get_collection(client, "committee_funding_sources", database_name=f"enriched_{cycle}")
            
            # Clear existing data
            funding_collection.delete_many({})
            context.log.info(f"Cleared existing committee_funding_sources for cycle {cycle}")
            
            # Load committee names and types for enrichment
            committee_info = {}
            for cmte in cm_collection.find():
                committee_info[cmte['CMTE_ID']] = {
                    'name': cmte.get('CMTE_NM', 'Unknown'),
                    'type': cmte.get('CMTE_TP', 'Unknown')
                }
            
            context.log.info(f"Loaded {len(committee_info):,} committee info records")
            context.log.info("")
            
            # ========================================================================
            # STEP 3: Find all donors TO tracked candidates' committees
            # ========================================================================
            context.log.info("STEP 3: Finding donors to tracked candidates' committees")
            context.log.info("-" * 80)
            
            # NEW APPROACH: Only query for transactions WHERE:
            #   OTHER_ID (recipient) = tracked candidate committee
            #   TRANSACTION_TP = "24K" (direct contributions)
            # This focuses our upstream tracing ONLY on relevant committees
            
            donor_committees = {}  # Track all unique donors to tracked candidates
            
            query_result = itpas2_collection.find({
                "ENTITY_TP": {"$in": ["COM", "PAC", "PTY", "CCM"]},
                "TRANSACTION_TP": "24K",
                "TRANSACTION_AMT": {"$ne": None},
                "OTHER_ID": {"$in": tracked_committee_ids}  # NEW: Only tracked committees!
            })
            
            txn_count = 0
            for txn in query_result:
                donor_id = txn.get('CMTE_ID')       # Committee GIVING money
                recipient_id = txn.get('OTHER_ID')   # Tracked candidate's committee
                amount = txn.get('TRANSACTION_AMT', 0)
                
                if not donor_id or not recipient_id or amount <= 0:
                    continue
                
                # Track which candidates this donor gave to
                if donor_id not in donor_committees:
                    donor_info = committee_info.get(donor_id, {'name': 'Unknown', 'type': 'Unknown'})
                    donor_committees[donor_id] = {
                        'committee_id': donor_id,
                        'committee_name': donor_info['name'],
                        'committee_type': donor_info['type'],
                        'donated_to_tracked_committees': set(),
                        'total_to_tracked': 0,
                        'transaction_count': 0
                    }
                
                donor_committees[donor_id]['donated_to_tracked_committees'].add(recipient_id)
                donor_committees[donor_id]['total_to_tracked'] += amount
                donor_committees[donor_id]['transaction_count'] += 1
                txn_count += 1
            
            stats['donor_committees_found'] = len(donor_committees)
            context.log.info(f"   ‚úÖ Found {len(donor_committees):,} unique donor committees")
            context.log.info(f"   ‚úÖ Total {txn_count:,} transactions to tracked candidates")
            context.log.info("")
            
            # ========================================================================
            # STEP 4: Separate donors by type (Corporate PACs vs Political PACs)
            # ========================================================================
            context.log.info("STEP 4: Separating corporate PACs from political PACs")
            context.log.info("-" * 80)
            
            corporate_pac_types = {'Q', 'N'}  # Q = Qualified connected PAC, N = Non-qualified
            political_pac_types = {'O', 'W', 'I', 'U'}  # O = Super PAC, W = Non-connected, I = Independent, U = Super PAC variant
            
            corporate_pacs = []
            political_pacs = []
            
            for donor_id, donor_data in donor_committees.items():
                cmte_type = donor_data['committee_type']
                
                if cmte_type in corporate_pac_types:
                    corporate_pacs.append(donor_id)
                elif cmte_type in political_pac_types:
                    political_pacs.append(donor_id)
                else:
                    # Other types (S=candidate, X=party, etc.) - treat as political for now
                    political_pacs.append(donor_id)
            
            stats['corporate_pacs_reclassified'] = len(corporate_pacs)
            stats['political_pacs_traced'] = len(political_pacs)
            
            context.log.info(f"   Corporate PACs (Q/N): {len(corporate_pacs):,} committees")
            context.log.info(f"   Political PACs (O/W/I/U): {len(political_pacs):,} committees")
            context.log.info(f"   ‚Üí Will trace upstream ONLY for political PACs")
            context.log.info("")
            
            # ========================================================================
            # STEP 5: Trace upstream funding for political PACs only
            # ========================================================================
            context.log.info("STEP 5: Tracing upstream funding for political PACs")
            context.log.info("-" * 80)
            
            # For each political PAC, find who funds THEM
            # Query pas2 WHERE OTHER_ID = political PAC committee ID
            
            funding_by_political_pac = {}
            
            if political_pacs:
                context.log.info(f"Querying pas2 for upstream sources of {len(political_pacs):,} political PACs...")
                
                upstream_query = itpas2_collection.find({
                    "ENTITY_TP": {"$in": ["COM", "PAC", "PTY", "CCM"]},
                    "TRANSACTION_TP": "24K",
                    "TRANSACTION_AMT": {"$ne": None},
                    "OTHER_ID": {"$in": political_pacs}  # Find who gave TO political PACs
                })
                
                upstream_count = 0
                for txn in upstream_query:
                    upstream_donor_id = txn.get('CMTE_ID')  # Who is funding the political PAC
                    political_pac_id = txn.get('OTHER_ID')  # The political PAC receiving funds
                    amount = txn.get('TRANSACTION_AMT', 0)
                    
                    if not upstream_donor_id or not political_pac_id or amount <= 0:
                        continue
                    
                    if political_pac_id not in funding_by_political_pac:
                        funding_by_political_pac[political_pac_id] = {
                            'from_committees': {},
                            'from_individuals': {},  # Future: indiv.zip
                            'from_organizations': {}
                        }
                    
                    # Add upstream donor
                    if upstream_donor_id not in funding_by_political_pac[political_pac_id]['from_committees']:
                        upstream_info = committee_info.get(upstream_donor_id, {'name': 'Unknown', 'type': 'Unknown'})
                        funding_by_political_pac[political_pac_id]['from_committees'][upstream_donor_id] = {
                            'committee_id': upstream_donor_id,
                            'committee_name': upstream_info['name'],
                            'committee_type': upstream_info['type'],
                            'total_amount': 0,
                            'transaction_count': 0,
                            'transactions': []
                        }
                    
                    funding_by_political_pac[political_pac_id]['from_committees'][upstream_donor_id]['total_amount'] += amount
                    funding_by_political_pac[political_pac_id]['from_committees'][upstream_donor_id]['transaction_count'] += 1
                    
                    # Keep top 10 transactions
                    transactions = funding_by_political_pac[political_pac_id]['from_committees'][upstream_donor_id]['transactions']
                    txn_data = {
                        'amount': amount,
                        'date': txn.get('TRANSACTION_DT'),
                        'transaction_id': txn.get('TRAN_ID')
                    }
                    
                    if len(transactions) < 10:
                        transactions.append(txn_data)
                    else:
                        transactions.sort(key=lambda x: x['amount'], reverse=True)
                        if amount > transactions[-1]['amount']:
                            transactions[-1] = txn_data
                    
                    upstream_count += 1
                
                context.log.info(f"   ‚úÖ Found {upstream_count:,} upstream funding transactions")
                context.log.info(f"   ‚úÖ {len(funding_by_political_pac):,} political PACs have upstream data")
            else:
                context.log.info("   ‚ö†Ô∏è  No political PACs to trace")
            
            context.log.info("")
            
            # ========================================================================
            # STEP 6: Build committee funding records
            # ========================================================================
            context.log.info("STEP 6: Building committee funding records")
            context.log.info("-" * 80)
                "OTHER_ID": {"$nin": [None, ""]}  # Only transactions with recipient committee
            })
            
            earmark_count = 0  # Track earmarked contributions
            
            for txn in org_contributions:
                donor_id = txn.get('CMTE_ID')  # Committee making the contribution
                recipient_id = txn.get('OTHER_ID')  # Committee receiving the contribution
                org_name = txn.get('NAME', 'Unknown')
                amount = txn.get('TRANSACTION_AMT', 0)
                
                if not recipient_id or not donor_id or amount <= 0:
                    continue
                
                # These are committee‚Üícommittee transfers with org attribution
                # Add to recipient's from_committees
                if donor_id not in funding_by_committee[recipient_id]['from_committees']:
                    donor_info = committee_info.get(donor_id, {'name': 'Unknown', 'type': 'Unknown'})
                    funding_by_committee[recipient_id]['from_committees'][donor_id] = {
                        'transactions': [],
                        'total': 0,
                        'count': 0
                    }
                
                # Always aggregate totals
                funding_by_committee[recipient_id]['from_committees'][donor_id]['total'] += amount
                funding_by_committee[recipient_id]['from_committees'][donor_id]['count'] += 1
                
                # Only keep top 10 transactions (memory optimization)
                transactions = funding_by_committee[recipient_id]['from_committees'][donor_id]['transactions']
                txn_data = {
                    'amount': amount,
                    'date': txn.get('TRANSACTION_DT'),
                    'transaction_id': txn.get('TRAN_ID'),
                    'memo': f"Attributed to: {org_name}"
                }
                
                if len(transactions) < 10:
                    transactions.append(txn_data)
                else:
                    # Keep top 10 by amount
                    transactions.sort(key=lambda x: x['amount'], reverse=True)
                    if amount > transactions[-1]['amount']:
                        transactions[-1] = txn_data
                
                earmark_count += 1
            
            context.log.info(f"   ‚úÖ Found {earmark_count:,} org-attributed committee contributions")
            context.log.info("   ‚ö†Ô∏è  Note: True org‚Üícommittee contributions not available in pas2 (would need different data source)")
            
            # === BUILD COMMITTEE FUNDING RECORDS ===
            context.log.info("üèóÔ∏è  Building committee funding records...")
            
            # RECLASSIFY: Corporate/Union PACs (Q/N types) should go in from_organizations
            # Q = Qualified non-party PAC (connected to corp/union/trade assoc)
            # N = Non-qualified PAC (smaller connected PACs)
            # These represent organizational interests, not political causes
            # 
            # Political PACs (W/O/I/etc.) stay in from_committees:
            # W = Non-connected PAC (ideological causes like Conservative Leadership PAC)
            # O = Super PAC (independent expenditure only)
            # I = Independent expenditure PAC
            corporate_pac_types = {'Q', 'N'}  # Qualified/Non-qualified connected PACs
            
            batch = []
            reclassified_count = 0
            political_pac_count = 0
            
            for recipient_id, sources in funding_by_committee.items():
                # Get committee info
                cmte_info = committee_info.get(recipient_id, {'name': 'Unknown', 'type': 'Unknown'})
                
                # Build from_committees and from_organizations lists
                # Reclassify based on donor committee type
                from_committees = []
                total_from_committees = 0
                
                for donor_id, data in sources['from_committees'].items():
                    donor_info = committee_info.get(donor_id, {'name': 'Unknown', 'type': 'Unknown'})
                    donor_type = donor_info.get('type', 'Unknown')
                    
                    # Sort transactions by amount (descending), keep top 10
                    top_transactions = sorted(
                        data['transactions'],
                        key=lambda x: x['amount'],
                        reverse=True
                    )[:10]
                    
                    # Reclassify corporate/union PACs as organizations
                    if donor_type in corporate_pac_types:
                        # Add to from_organizations instead
                        org_key = donor_info['name']
                        if org_key not in sources['from_organizations']:
                            sources['from_organizations'][org_key] = {
                                'contributions': [],
                                'total': 0,
                                'count': 0,
                                'committee_id': donor_id,
                                'committee_type': donor_type
                            }
                        
                        # Transfer transactions to organizations
                        sources['from_organizations'][org_key]['contributions'].extend(
                            [{'amount': t['amount'], 'date': t.get('date'), 'transaction_id': t.get('transaction_id')} 
                             for t in data['transactions']]
                        )
                        sources['from_organizations'][org_key]['total'] += data['total']
                        sources['from_organizations'][org_key]['count'] += data['count']
                        reclassified_count += 1
                    else:
                        # Keep as political committee
                        from_committees.append({
                            'committee_id': donor_id,
                            'committee_name': donor_info['name'],
                            'committee_type': donor_type,
                            'total_amount': data['total'],
                            'transaction_count': data['count'],
                            'transactions': top_transactions
                        })
                        total_from_committees += data['total']
                        political_pac_count += 1
                
                # Sort committees by total amount (descending)
                from_committees.sort(key=lambda x: x['total_amount'], reverse=True)
                
                # Build from_individuals list
                from_individuals = []
                total_from_individuals = 0
                for donor_key, data in sources['from_individuals'].items():
                    name, employer = donor_key.split('|')
                    
                    # Sort contributions by amount (descending), keep top 10
                    top_contributions = sorted(
                        data['contributions'],
                        key=lambda x: x['amount'],
                        reverse=True
                    )[:10]
                    
                    from_individuals.append({
                        'contributor_name': name,
                        'employer': employer,
                        'occupation': top_contributions[0].get('occupation') if top_contributions else None,
                        'total_amount': data['total'],
                        'contribution_count': data['count'],
                        'contributions': top_contributions
                    })
                    total_from_individuals += data['total']
                
                # Sort individuals by total amount (descending)
                from_individuals.sort(key=lambda x: x['total_amount'], reverse=True)
                
                # Build from_organizations list
                # Now includes reclassified corporate/union PACs (Q/N types)
                from_organizations = []
                total_from_organizations = 0
                for org_name, data in sources['from_organizations'].items():
                    # Sort contributions by amount (descending), keep top 10
                    top_contributions = sorted(
                        data['contributions'],
                        key=lambda x: x['amount'],
                        reverse=True
                    )[:10]
                    
                    org_record = {
                        'organization_name': org_name,
                        'total_amount': data['total'],
                        'contribution_count': data['count'],
                        'contributions': top_contributions
                    }
                    
                    # Include committee_id/type if this is a reclassified PAC
                    if 'committee_id' in data:
                        org_record['pac_committee_id'] = data['committee_id']
                        org_record['pac_committee_type'] = data['committee_type']
                        org_record['organization_type'] = 'Corporate PAC' if data['committee_type'] == 'Q' else 'Union/Trade PAC'
                    
                    from_organizations.append(org_record)
                    total_from_organizations += data['total']
                
                # Sort organizations by total amount (descending)
                from_organizations.sort(key=lambda x: x['total_amount'], reverse=True)
                
                # Calculate transparency metrics
                total_disclosed = total_from_committees + total_from_individuals + total_from_organizations
                
                # TODO: Compare against committee's reported total receipts from webk/webl
                # For now, transparency_score = 1.0 if we have any disclosed sources
                transparency_score = 1.0 if total_disclosed > 0 else 0.0
                
                # Red flags detection
                red_flags = []
                
                # Flag if receiving from Type C committees (dark money)
                dark_money_sources = [c for c in from_committees if c['committee_type'] == 'C']
                if dark_money_sources:
                    red_flags.append({
                        'type': 'dark_money_source',
                        'description': f"Receives from {len(dark_money_sources)} Type C (dark money) committees",
                        'severity': 'high',
                        'amount': sum(c['total_amount'] for c in dark_money_sources)
                    })
                
                # Flag if receiving from multiple other Super PACs (shell game)
                super_pac_sources = [c for c in from_committees if c['committee_type'] in ['O', 'U']]
                if len(super_pac_sources) >= 3:
                    red_flags.append({
                        'type': 'shell_game',
                        'description': f"Receives from {len(super_pac_sources)} other Super PACs (potential layering)",
                        'severity': 'medium',
                        'amount': sum(c['total_amount'] for c in super_pac_sources)
                    })
                
                record = {
                    '_id': recipient_id,
                    'committee_id': recipient_id,
                    'committee_name': cmte_info['name'],
                    'committee_type': cmte_info['type'],
                    'cycle': cycle,
                    
                    'funding_sources': {
                        'from_committees': from_committees,
                        'from_individuals': from_individuals,
                        'from_organizations': from_organizations
                    },
                    
                    'transparency': {
                        'total_disclosed': total_disclosed,
                        'from_committees': total_from_committees,
                        'from_individuals': total_from_individuals,
                        'from_organizations': total_from_organizations,
                        'transparency_score': transparency_score,
                        'red_flags': red_flags
                    },
                    
                    'computed_at': datetime.now()
                }
                
                batch.append(record)
                stats['total_upstream_amount'] += total_disclosed
            
            # Insert batch
            if batch:
                funding_collection.insert_many(batch, ordered=False)
                context.log.info(f"‚úÖ {cycle}: Created {len(batch):,} committee funding records")
                context.log.info(f"   üìä Reclassified {reclassified_count:,} corporate/union PACs as organizations")
                context.log.info(f"   üìä Kept {political_pac_count:,} political PACs in committees")
                stats['committees_with_funding'] += len(batch)
                stats['cycles_processed'].append(cycle)
                
                # Update source type stats
                for record in batch:
                    stats['by_source_type']['from_committees'] += record['transparency']['from_committees']
                    stats['by_source_type']['from_individuals'] += record['transparency']['from_individuals']
                    stats['by_source_type']['from_organizations'] += record['transparency']['from_organizations']
            else:
                context.log.warning(f"‚ö†Ô∏è  {cycle}: No funding records created")
            
            # Create indexes
            funding_collection.create_index([("committee_id", 1)])
            funding_collection.create_index([("committee_type", 1)])
            funding_collection.create_index([("transparency.total_disclosed", -1)])
            funding_collection.create_index([("transparency.transparency_score", 1)])
            funding_collection.create_index([("transparency.red_flags.type", 1)])
    
    return Output(
        value=stats,
        metadata={
            "committees_with_funding": stats['committees_with_funding'],
            "total_upstream_amount": MetadataValue.float(stats['total_upstream_amount']),
            "cycles_processed": MetadataValue.json(stats['cycles_processed']),
            "by_source_type": MetadataValue.json(stats['by_source_type']),
        }
    )
